""" Question 1: Nth Fibonacci 
    A fibonacci sequence is where the first number = 0, second number = 1, 
    and nth number = (n-1) + (n-2)

    METHOD 1: 0(n) time | 0(n) space
    METHOD 2: 0(n) time | 0(1) space
"""


def getNthFib(n):
    if n < 2:
        return 0
    sequence = [0 for _ in range(n)]
    sequence[0] = 0
    sequence[1] = 1
    for i in range(2, n):
        sequence[i] = sequence[i - 1] + sequence[i - 2]
    return sequence[-1]


def getNthFib(n):
    if n < 2:
        return 0
    n1, n2 = 0, 1
    for i in range(2, n):
        n1, n2 = n2, n1 + n2

        # temp = n1
        # n1 = n2
        # n2 = temp + n1
    return n2


""" Question 2: Product Sum
    Write a func that takes in a "special array" and returns the product sum . 
    A "special" array is a non-empty array that contains either intergers or other 'special' arrays. 
    The product of a special array is the sum of its elements, where special array inside it are summed themselves and 
    then multiplied by their level of depth. 

    The depth of a special array, is how far theyre nested. E.g [] -> depth = 1, [[]] -> depth = 2, [[[]]] -> depth = 3

    Therefore, the product of [x, y] is x + y,
                              [x, [y, z]] is x +2 * (y + z)
                              [x, [y, [z]]] is x + 2 * (y + 3z)

    e.g: array=[5, 2, [7, -1], 3, [6, [-13, 8], 4]] --> 12 // 5 + 2+ 2 * (7-1) + 3 + 2 * (6 + 3 * (-13 + 8) + 4)

    METHOD: 0(n) time | 0(d) space 
    start with depth = 1
    For any inner array found, solve recursively and increase the depth. 
"""


def productSum(array):
    stack, depth = [], 1
    stack += get_inner_sum(array, depth)
    return sum(stack)


def get_inner_sum(array, depth):
    inner_stack = []
    for element in array:
        if isinstance(element, int):
            inner_stack.append(element)
        else:
            inner_stack += get_inner_sum(element, depth + 1)
    return [depth * sum(inner_stack)]


""" Question 3: Permutation

    METHOD: 0(n*n!) time | 0(n*n!) space
"""


def getPermutations(array):
    result = []

    if len(array) == 1:
        return [array.copy()]  # form a new array and don't modify the main array

    for _ in range(len(array)):
        # remove one element, recursively
        n = array.pop(0)
        perms = getPermutations(array)

        # add the removed element to each permutations
        for perm in perms:
            perm.append(n)
            result.append(
                perm
            )  # TAKE NOTE: if the question demands it to be unique, check if a similar perm is not
            # already in result before add it

        # add the removed element to the end, for the next permutations
        array.append(n)
    return result


""" Question 4: Power set
    Write a func that takes in an array of unique intergers and returns its powerset. 
    Power-set is a subset of all the elements in the array. 
    [1, 2] -> [[], [1], [2], [1,2]]
    NOTE: The return order doesn't matter 

    e.g: array=[1, 2, 3] -> [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]

    METHOD: 0(n^2) time | 0(n^2) space
        Since there is always an empty list in the return, 
        Loop through the given array and generate a new set of list and append it to the sequence. 
        The new set of lists can be generated by adding the current number to ALL the existing lists in the sequence
        When new set of lists are formed, add them to the original sequence. Continue to the next Number 
"""


def powerset(array):
    sequence = [[]]
    for number in array:
        new_lists = []
        for inner_list in sequence:
            copied_list = inner_list.copy()
            copied_list.append(number)
            new_lists.append(copied_list)

        sequence += new_lists
    return sequence


""" Question 5: Phone Number mnemonics 
    The phone pad of your phone, almost every digit is associated with an alphabet 
    8464747328 = timisgreat
    2686463 = antoine OR ant6468
    Note: A number can represent multiple alphabets, e.g (2 - abc)
    ------   -----   -----
    |     | |     | |     |
    |  1  | |  2  | |  3  |
    |     | | abc | | def |
    ------   -----   -----
    |     | |     | |     |
    |  4  | |  5  | |  6  |
    | ghi | | jkl | | mno |
    ------   -----   -----
    |     | |     | |     |
    |  7  | |  8  | |  9  |
    | pqrs| | tuv | | wxyz|
    ------   -----   -----
            |     | 
            |  0  | 
            |     | 
            -------
    
    A mnemonic is defined as a pattern of ideas, character, associations that helps one in remembering something.
    Companies often use mnemonic for their phone number to make it easeir to remember. 

    Write a func that takes a string of phone numbers and returns all mnemonics for the phone number in any order.

    e.g: phoneNumber = "1905" -> ['1w0j', '1w0k', '1w0l', '1x0j', '1x0k', '1x0l', '1y0j', '1y0k', '1y0l', '1z0j', '1z0k', '1z0l']

    METHOD: 0(4^n * n) time | 0(4^n * n) space
        We need to keep track of the current mnemonics, anytime there is a chnage at any point, we go all the way to chnage the others
        to the end. 
        If we're at the end, we've reach out base base, append it to the result. 

"""


def phoneNumberMnemonics(phoneNumber):
    # current mnemonic we're generating
    currentMnemonic = ["0"] * len(phoneNumber)

    # save all the mnemonic we've found
    result = []

    phoneNumberMnemonicsHelper(0, phoneNumber, currentMnemonic, result)
    return result


def phoneNumberMnemonicsHelper(idx, phoneNumber, currentMnemonic, result):
    # Base case - if we're at currentMnemonic's last character, then we conclude we've generated a case
    if idx == len(phoneNumber):
        mnemonic = "".join(currentMnemonic)
        result.append(mnemonic)
    else:
        digit = phoneNumber[idx]
        letters = DIGIT_LETTERS[digit]

        for letter in letters:
            # Chnage the current idx letter and move to the next
            currentMnemonic[idx] = letter
            phoneNumberMnemonicsHelper(idx + 1, phoneNumber, currentMnemonic, result)


DIGIT_LETTERS = {
    "0": ["0"],
    "1": ["1"],
    "2": ["a", "b", "c"],
    "3": ["d", "e", "f"],
    "4": ["g", "h", "i"],
    "5": ["j", "k", "l"],
    "6": ["m", "n", "o"],
    "7": ["p", "q", "r", "s"],
    "8": ["t", "u", "v"],
    "9": ["w", "x", "y", "z"],
}


""" Question 6: Staircase Traversal 
    Given 2 intergers, representing the height of a staircase, and the maximum number of steps that you can advance up 
    the staircase at a time, Write a func that returns the number of ways in which you can climb the staircase 

    NOTE: maxSteps <= height 
    e.g: height = 3, maxSteps = 2 --> 3 ways ((1,1,1), (1,2), (2,1))
         height = 4, maxSteps = 2 --> 5 ways ((1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2))

    There is 1 way to get to height 0 (DO NOTHING)
    There is 1 way to get to height 1 
    There is 2 ways to get to height 2 
    There is 3 ways to get to height 3 
    There is 5 ways to get to height 5 

    THE PATTERN: Depending on the maxSteps, that's how deep we need to sum the previouses to get the current, 
    - if maxSteps = 2, The sum of the previous two, gives the current 
    - if maxSteps = 3, The sum of the previous three, gives the current 

    METHOD: 0(n) time | 0(n) space 
        
"""


def staircaseTraversal(height, maxSteps):
    # Create a list of zeros with length equal to height + 1
    # (because we start counting stairs from 0)
    numberOfWaysToStairs = [0] * (height + 1)

    # Set the number of ways to climb 0 and 1 staircases to 1 since there is only one way to do it.
    numberOfWaysToStairs[0] = 1
    numberOfWaysToStairs[1] = 1

    # Loop through each staircase from 2 up to and including the total number of stairs
    for i in range(2, height + 1):
        # To calculate number of ways to reach the current stair,
        # consider only the maxSteps previous stairs
        # (or all stairs if there are fewer than maxSteps stairs before the current stair).
        # This is done by using a sliding window approach where the start index is at i-maxSteps,
        # but not less than 0 (as stairs can't have negative indices).
        start = i - maxSteps if i - maxSteps >= 0 else 0
        endIdx = i

        # Extract a subarray from the numberOfWaysToStairs list containing the relevant stairs
        sub_array = numberOfWaysToStairs[start:endIdx]

        # The number of ways to reach the ith staircase is the sum of the number of
        # ways to reach the maxSteps preceding stairs.
        numberOfWaysToStairs[i] = sum(sub_array)

    # Return the number of ways to reach the top of the staircase (i.e. last element of the numberOfWaysToStairs list)
    return numberOfWaysToStairs[-1]


""" Question 7: Lowest common manager
    Given 3 inputs (topManager, reportOne, reportTwo) of an organisation charts (OrgChart) that have a (directReports) pointing to the
    employees under them. i.e each person has a list of employee under them.  Write an algorithm that returns the lowest common manager of 
    reportOne and reportTwo
    
    e.g:                               topManager = Node A
                                        reportOne = Node E 
                                        reportTwo = Node I 
                                        A
                                     /   \
                                    B    C
                                  / \   / \
                                D   E F   G 
                              /  \ 
                            H    I 
        --> Node B 

    METHOD 1:  0(d) time | 0(n) space
        NOTE: This question is common to "Youngest common ancestor" in Graphs. CHECK 
        I used the same procedure to solve the problem but couldnt pass all test cases. In this case, 
        there was no pointer to the ancestor, so I used a hashMap to keep track of all the ancestor, 
        then I saved history of the ancestor already visited from reportOne, and when going through the 
        ancestor of reportTwo, if i find any one already saved, then thats a common ancestor. 

    METHOD 2: 0(n) time | 0(d) space 
        By recursion, I try to go through each manager reporters, if i find both reports, i assume there is another lower
        manager. Up until i discover i can no longer find both reporters. Then i Know i was their common manager
        
"""
# METHOD 1
def getLowestCommonManager(topManager, reportOne, reportTwo):
    if topManager == reportOne or topManager == reportTwo:
        return topManager

    ancestorTree = {
        topManager: None,
    }
    buildAncestorsTree(ancestorTree, topManager)

    history = set()
    while reportOne is not None:
        ancestor = ancestorTree[reportOne]
        history.add(ancestor)
        reportOne = ancestor

    while reportTwo is not None:
        ancestor = ancestorTree[reportTwo]
        if ancestor in history:
            return ancestor
        reportTwo = ancestor


def buildAncestorsTree(ancestorTree, topManager):
    nodes = [topManager]
    while nodes:
        currentAncestor = nodes.pop(0)
        for reporter in currentAncestor.directReports:
            ancestorTree[reporter] = currentAncestor
            nodes.append(reporter)


# METHOD 2
# function to get the lowest common manager given two reports and a top-level manager
def getLowestCommonManager(topManager, reportOne, reportTwo):
    # loop through all direct reports of the top-level manager
    for reporter in topManager.directReports:
        # search for the number of reporters found in this sub-tree
        numberOfReportersFound = searchReporters(reporter, reportOne, reportTwo)

        # if one of the reports is found in this sub-tree, return the current manager as the lowest common manager
        if numberOfReportersFound == 1:
            return topManager

        # if both reports are found in this sub-tree, there may be another lower manager with both reports as direct reports
        if numberOfReportersFound == 2:
            # call the same function recursively for the next level down
            return getLowestCommonManager(reporter, reportOne, reportTwo)


# function to search for the given reports in the tree
def searchReporters(currentManager, reportOne, reportTwo):
    # start with the current manager
    queue = [currentManager]
    # keep track of how many reports are found
    found = 0
    while len(queue):
        # remove the first element from the queue
        node = queue.pop(0)
        # add all direct reports of the current node to the queue
        for reporter in node.directReports:
            queue.append(reporter)
        # check if the current node is one of the two reports we are searching for, and increment "found" if so
        if node == reportOne:
            found += 1
        if node == reportTwo:
            found += 1
    return found


# This is an input class. Do not edit.
# class representing each employee and their direct reports
class OrgChart:
    def __init__(self, name):
        # name of the employee
        self.name = name
        # list of direct reports for this employee, initialized as empty
        self.directReports = []


""" Question 8: Interweaving Strings
    Write a func that takes three strings and returns a boolean representing whether the third string
    can be formed by interweaving the first two strings.

    To interweave a string means to merge them by alternating their letters without any specific pattern. 
    for instance, strings "abc" and "123" can be interwoven as "a1b2c3", "abc123", "ab1c23" ... etc 

    Letters in the string must maintain their relative ordering in the interwoven strings
    
    e.g: 
        one='algoexpert' 
        two='your-dream-job'
        three='your-algodream-expertjob'       --> True 

        one='aabcc' 
        two='dbbca' 
        three='aadbbbaccc'         --> False               

    METHOD:  
"""


""" Question 9: Solve Sudoku
    You're given a 2D array that represent a 9X9 partially solved Sudoku board. Write a function 
    that returns the solved Sudoku board. 

    Sudoku is a famous number-placement puzzle in which you need to fill 9x9 grid with integers 
    in the range of 1-9. Each 9x9 Sudoku board is split into 9 3x3 subgrids, as seen below

    -  -  3   -  2  -   6  -  - 
    9  -  -   3  -  5   -  -  1 
    -  -  1   8  -  6   4  -  - 
   ------          -------
    -  -  8   1  -  2   9  -  - 
    7  -  -   -  -  -   -  -  8 
    -  -  6   7  -  8   2  -  - 
   ------          -------
    -  -  2   6  -  9   5  -  - 
    8  -  -   2  -  3   -  -  9 
    -  -  5   -  1  -   3  -  - 
   ------          -------

   The idea is to fill the grid such that each row, column, and 3x3 subgrid contains the number 1-9
   exactly once. In other words, no row/column may contain the same digit more than once and 
   non of the 9 3x3 subgrid may contain the same digit more than once

   Your input for this problem will always be a partially filled 9x9 2D array. 0 in the arrays represents
   empty, valid numbers are 1-9 
    
    e.g: 
                 

    METHOD: 0(1) time | 0(1) space - Because we know the constant space and time 
"""


""" Question 10: Generate Div Tag 
    Write a func that takes a positive integer n, and returns strings of arrays of all the possible
    matching div tags. 

    NOTE: A tag is only valid if <div></div 
    In any order, The output should contain exactly n opening tags and n closing tags 
    
    e.g: numberOfTags= 2, --> [
                            "<div><div></div</div",
                            "<div></div<div></div",
                            ]
                 

    METHOD: 
"""
