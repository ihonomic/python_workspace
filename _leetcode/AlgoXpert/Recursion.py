""" Question 1: Nth Fibonacci 
    A fibonacci sequence is where the first number = 0, second number = 1, 
    and nth number = (n-1) + (n-2)

    METHOD 1: 0(n) time | 0(n) space
    METHOD 2: 0(n) time | 0(1) space
"""


def getNthFib(n):
    if n < 2:
        return 0
    sequence = [0 for _ in range(n)]
    sequence[0] = 0
    sequence[1] = 1
    for i in range(2, n):
        sequence[i] = sequence[i - 1] + sequence[i - 2]
    return sequence[-1]


def getNthFib(n):
    if n < 2:
        return 0
    n1, n2 = 0, 1
    for i in range(2, n):
        n1, n2 = n2, n1 + n2

        # temp = n1
        # n1 = n2
        # n2 = temp + n1
    return n2


""" Question 2: Product Sum
    Write a func that takes in a "special array" and returns the product sum . 
    A "special" array is a non-empty array that contains either intergers or other 'special' arrays. 
    The product of a special array is the sum of its elements, where special array inside it are summed themselves and 
    then multiplied by their level of depth. 

    The depth of a special array, is how far theyre nested. E.g [] -> depth = 1, [[]] -> depth = 2, [[[]]] -> depth = 3

    Therefore, the product of [x, y] is x + y,
                              [x, [y, z]] is x +2 * (y + z)
                              [x, [y, [z]]] is x + 2 * (y + 3z)

    e.g: array=[5, 2, [7, -1], 3, [6, [-13, 8], 4]] --> 12 // 5 + 2+ 2 * (7-1) + 3 + 2 * (6 + 3 * (-13 + 8) + 4)

    METHOD: 0(n) time | 0(d) space 
    start with depth = 1
    For any inner array found, solve recursively and increase the depth. 
"""


def productSum(array):
    stack, depth = [], 1
    stack += get_inner_sum(array, depth)
    return sum(stack)


def get_inner_sum(array, depth):
    inner_stack = []
    for element in array:
        if isinstance(element, int):
            inner_stack.append(element)
        else:
            inner_stack += get_inner_sum(element, depth + 1)
    return [depth * sum(inner_stack)]


""" Question 3: Permutation

    METHOD: 0(n*n!) time | 0(n*n!) space
"""


def getPermutations(array):
    result = []

    if len(array) == 1:
        return [array.copy()]  # form a new array and don't modify the main array

    for _ in range(len(array)):
        # remove one element, recursively
        n = array.pop(0)
        perms = getPermutations(array)

        # add the removed element to each permutations
        for perm in perms:
            perm.append(n)
            result.append(
                perm
            )  # TAKE NOTE: if the question demands it to be unique, check if a similar perm is not
            # already in result before add it

        # add the removed element to the end, for the next permutations
        array.append(n)
    return result


""" Question 4: Power set
    Write a func that takes in an array of unique intergers and returns its powerset. 
    Power-set is a subset of all the elements in the array. 
    [1, 2] -> [[], [1], [2], [1,2]]
    NOTE: The return order doesn't matter 

    e.g: array=[1, 2, 3] -> [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]

    METHOD: 0(n^2) time | 0(n^2) space
        Since there is always an empty list in the return, 
        Loop through the given array and generate a new set of list and append it to the sequence. 
        The new set of lists can be generated by adding the current number to ALL the existing lists in the sequence
        When new set of lists are formed, add them to the original sequence. Continue to the next Number 
"""


def powerset(array):
    sequence = [[]]
    for number in array:
        new_lists = []
        for inner_list in sequence:
            copied_list = inner_list.copy()
            copied_list.append(number)
            new_lists.append(copied_list)

        sequence += new_lists
    return sequence


""" Question 5: Phone Number mnemonics 
    Write a func that takes i
    

    e.g: 

    METHOD: 0
"""
